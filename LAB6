
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <string.h>
#include <fcntl.h>
#define HISTORY_SIZE 5 
#define MAX_LINE 80

int main()
{
    int history = 0;
    char* HF[HISTORY_SIZE];
    int historyCount = 0;

    char *args[MAX_LINE / 2 + 1]; // Mảng để lưu trữ lệnh và các tham số của lệnh
    int should_run = 1;           // Biến cờ để xác định chương trình có tiếp tục chạy hay không

    // Cấp phát bộ nhớ
    for (int i = 0; i < MAX_LINE / 2 + 1; i++) {
        args[i] = malloc(MAX_LINE);
    }

    for (int i = 0; i < HISTORY_SIZE; i++) {
        HF[i] = malloc(MAX_LINE);
    }

    while (should_run)
    {
        printf("it007sh> "); // Dấu nhắc
        fflush(stdout); // Xóa bộ đệm
        
        char command[MAX_LINE]; // Khai báo câu lệnh có tối đa 80 ký tự
        fgets(command, MAX_LINE, stdin); // Nhập câu lệnh
        
        // Loại bỏ ký tự xuống dòng ('\n') ở cuối chuỗi nhập vào
        command[strcspn(command, "\n")] = '\0'; // strcspn tìm vị trí đầu tiên có '\n' trong chuỗi; '\0' kết thúc chuỗi tại đó
        
        // Lưu lịch sử lại câu lệnh vừa nhập
        if (historyCount < HISTORY_SIZE) {
            strcpy(HF[historyCount], command);
            historyCount++;
        } 

        // Nếu lịch sử đã đầy
        else {
            // Xóa lệnh đầu tiên và dịch chuyển các lệnh cũ lên trên
            for (int i = 0; i < HISTORY_SIZE - 1; i++) {
                strcpy(HF[i], HF[i + 1]);
            }
            strcpy(HF[HISTORY_SIZE - 1], command); // Lưu lệnh mới nhất vào cuối
        }

        // Xử lý chuỗi nhập vào
        int index = 0;
        char *token = strtok(command, " "); // Tách chuỗi ký tự đầu tiên ra khi có dấu cách và lưu vào token
        while (token != NULL) { 
            args[index] = token; // args[i] bằng một chuỗi ký tự ngăn bởi dấu cách hay nói cách khác là một từ; có tối đa 41 từ trên một dòng
            token = strtok(NULL, " "); // Tiếp tục tách chuỗi đến khi token là ký tự rỗng khi bị cắt bởi dấu cách
            index++;
        }
        args[index] = NULL; // Từ cuối cùng sẽ là kết thúc chuỗi từ 

        // Kiểm tra lệnh đặc biệt của người dùng nhập vào như "exit" hay "HF"
        if (strcmp(args[0], "exit") == 0) {
            should_run = 0; // Dừng chương trình
            continue;
        }

        if (strcmp(command, "HF") == 0) {
            // In ra 5 lệnh gần nhất
            for (int i = 0; i < historyCount; i++) {
                printf("%s\n", HF[i]);
            }
        }

        //Kiểm tra người dùng có dùng chuyển hướng đầu ra hoặc đầu vào hay không
        
   
        // Tiến trình con
        pid_t pid = fork();
        if (pid == 0) {
            int input_fd, output_fd;
            int redirect_input = 0, redirect_output = 0;

            for (int j = 0; j < index; j++) {
                if (strcmp(args[j], ">") == 0) {
                    args[j] = NULL;
                    redirect_output = 1;

                    if (args[j + 1] == NULL) {
                        printf("Missing output file\n");
                        exit(EXIT_FAILURE);
                    }

                    output_fd = open(args[j + 1], O_WRONLY | O_CREAT | O_TRUNC, 0644);
                    if (output_fd < 0) {
                        perror("Fail. Try again.");
                        exit(EXIT_FAILURE);
                    }
                    dup2(output_fd, STDOUT_FILENO);
                    close(output_fd);
                } else if (strcmp(args[j], "<") == 0) {
                    args[j] = NULL;
                    redirect_input = 1;

                    if (args[j + 1] == NULL) {
                        printf("Missing input file\n");
                        exit(EXIT_FAILURE);
                    }

                    input_fd = open(args[j + 1], O_RDONLY);
                    if (input_fd < 0) {
                        perror("open");
                        exit(EXIT_FAILURE);
                    }
                    dup2(input_fd, STDIN_FILENO);
                    close(input_fd);
                }
            }
            // Thực thi lệnh
            if (redirect_input == 0 && redirect_output == 0)
                execvp(args[0], args);

            // Kiểm tra lỗi
            if (execvp(args[0], args) == -1 && strcmp(args[0],"HF") != 0) {
                printf("Command does not exist.\n");
                exit(EXIT_FAILURE);
            }
        }


        // Tiến trình cha
        else { 
            waitpid(pid, NULL, 0); // Chờ tiến trình con thực thi xong
        }
    }
    return 0;
}
